## API Report File for "@koordinates/xstate-tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { ActorRefFrom } from 'xstate';
import { AnyStateMachine } from 'xstate';
import { ContextFrom } from 'xstate';
import type { EventFrom } from 'xstate';
import { EventObject } from 'xstate';
import { History as History_2 } from 'history';
import { InputFrom } from 'xstate';
import type { IsNever } from 'xstate';
import { ParsedQuery } from 'query-string';
import { default as React_2 } from 'react';
import type { SnapshotFrom } from 'xstate';
import type { StateValue } from 'xstate';
import * as Z from 'zod';

// @public (undocumented)
export type Actions<TMachine extends AnyStateMachine, TSelectorsOutput, TOut> = (args: {
    send: ActorRefFrom<TMachine>["send"];
    selectors: TSelectorsOutput;
}) => TOut;

// @public
export type ActionsFrom<TMachine extends AnyXstateTreeMachine> = TMachine["_xstateTree"] extends XstateTreeMachineStateSchemaV2<any, any, infer TOut, any> ? TOut : never;

// @public (undocumented)
export type AnyRoute = {
    matches: (url: string, search: string) => any;
    reverse: any;
    navigate: any;
    getEvent: any;
    event: string;
    preload: any;
    basePath: string;
    history: () => XstateTreeHistory;
    parent?: AnyRoute;
    paramsSchema?: Z.ZodObject<any>;
    querySchema?: Z.ZodObject<any>;
    matcher: (url: string, query: ParsedQuery<string> | undefined) => any;
    reverser: any;
    redirect?: any;
    canMatch?: any;
};

// @public (undocumented)
export type AnyXstateTreeMachine = XstateTreeMachine<AnyStateMachine, any, any, any[]>;

// @public (undocumented)
export type ArgumentsForRoute<T> = T extends Route<infer TParams, infer TQuery, any, infer TMeta> ? RouteArguments<TParams, TQuery, TMeta> : never;

// @public
export function broadcast(event: GlobalEvents): void;

// @public
export function buildCreateRoute(history: () => XstateTreeHistory, basePath: string): {
    simpleRoute<TBaseRoute extends AnyRoute>(baseRoute?: TBaseRoute | undefined): <TEvent extends string, TParamsSchema extends Z.ZodObject<any, "strip", Z.ZodTypeAny, {
        [x: string]: any;
    }, {
        [x: string]: any;
    }> | undefined, TQuerySchema extends Z.ZodObject<any, "strip", Z.ZodTypeAny, {
        [x: string]: any;
    }, {
        [x: string]: any;
    }> | undefined, TMeta extends Record<string, unknown>>({ url, paramsSchema, querySchema, ...args }: {
        event: TEvent;
        url: string;
        paramsSchema?: TParamsSchema | undefined;
        querySchema?: TQuerySchema | undefined;
        meta?: TMeta | undefined;
        redirect?: RouteRedirect<MergeRouteTypes<RouteParams<TBaseRoute>, ResolveZodType<TParamsSchema>>, ResolveZodType<TQuerySchema>, MergeRouteTypes<RouteMeta<TBaseRoute>, TMeta> & SharedMeta> | undefined;
        preload?: RouteArgumentFunctions<void, MergeRouteTypes<RouteParams<TBaseRoute>, ResolveZodType<TParamsSchema>>, ResolveZodType<TQuerySchema>, MergeRouteTypes<RouteMeta<TBaseRoute>, TMeta>, RouteArguments<MergeRouteTypes<RouteParams<TBaseRoute>, ResolveZodType<TParamsSchema>>, ResolveZodType<TQuerySchema>, MergeRouteTypes<RouteMeta<TBaseRoute>, TMeta>>> | undefined;
        canMatch?: RouteArgumentFunctions<boolean, MergeRouteTypes<RouteParams<TBaseRoute>, ResolveZodType<TParamsSchema>>, ResolveZodType<TQuerySchema>, MergeRouteTypes<RouteMeta<TBaseRoute>, TMeta> & SharedMeta, RouteArguments<MergeRouteTypes<RouteParams<TBaseRoute>, ResolveZodType<TParamsSchema>>, ResolveZodType<TQuerySchema>, MergeRouteTypes<RouteMeta<TBaseRoute>, TMeta> & SharedMeta>> | undefined;
    }) => Route<MergeRouteTypes<RouteParams<TBaseRoute>, ResolveZodType<TParamsSchema>>, ResolveZodType<TQuerySchema>, TEvent, MergeRouteTypes<RouteMeta<TBaseRoute>, TMeta> & SharedMeta>;
    route<TBaseRoute_1 extends AnyRoute>(baseRoute?: TBaseRoute_1 | undefined): <TEvent_1 extends string, TParamsSchema_1 extends Z.ZodObject<any, "strip", Z.ZodTypeAny, {
        [x: string]: any;
    }, {
        [x: string]: any;
    }> | undefined, TQuerySchema_1 extends Z.ZodObject<any, "strip", Z.ZodTypeAny, {
        [x: string]: any;
    }, {
        [x: string]: any;
    }> | undefined, TMeta_1 extends Record<string, unknown>>({ event, matcher, reverser, paramsSchema, querySchema, redirect, preload, canMatch, }: {
        event: TEvent_1;
        paramsSchema?: TParamsSchema_1 | undefined;
        querySchema?: TQuerySchema_1 | undefined;
        meta?: TMeta_1 | undefined;
        redirect?: RouteRedirect<MergeRouteTypes<RouteParams<TBaseRoute_1>, ResolveZodType<TParamsSchema_1>>, ResolveZodType<TQuerySchema_1>, MergeRouteTypes<RouteMeta<TBaseRoute_1>, TMeta_1> & SharedMeta> | undefined;
        matcher: (url: string, query: ParsedQuery<string> | undefined) => false | (RouteArguments<MergeRouteTypes<RouteParams<TBaseRoute_1>, ResolveZodType<TParamsSchema_1>>, ResolveZodType<TQuerySchema_1>, MergeRouteTypes<RouteMeta<TBaseRoute_1>, TMeta_1>> & {
            matchLength: number;
        });
        reverser: RouteArgumentFunctions<string, MergeRouteTypes<RouteParams<TBaseRoute_1>, ResolveZodType<TParamsSchema_1>>, ResolveZodType<TQuerySchema_1>, MergeRouteTypes<RouteMeta<TBaseRoute_1>, TMeta_1>, RouteArguments<MergeRouteTypes<RouteParams<TBaseRoute_1>, ResolveZodType<TParamsSchema_1>>, ResolveZodType<TQuerySchema_1>, MergeRouteTypes<RouteMeta<TBaseRoute_1>, TMeta_1>>>;
        preload?: RouteArgumentFunctions<void, MergeRouteTypes<RouteParams<TBaseRoute_1>, ResolveZodType<TParamsSchema_1>>, ResolveZodType<TQuerySchema_1>, MergeRouteTypes<RouteMeta<TBaseRoute_1>, TMeta_1>, RouteArguments<MergeRouteTypes<RouteParams<TBaseRoute_1>, ResolveZodType<TParamsSchema_1>>, ResolveZodType<TQuerySchema_1>, MergeRouteTypes<RouteMeta<TBaseRoute_1>, TMeta_1>>> | undefined;
        canMatch?: RouteArgumentFunctions<boolean, MergeRouteTypes<RouteParams<TBaseRoute_1>, ResolveZodType<TParamsSchema_1>>, ResolveZodType<TQuerySchema_1>, MergeRouteTypes<RouteMeta<TBaseRoute_1>, TMeta_1> & SharedMeta, RouteArguments<MergeRouteTypes<RouteParams<TBaseRoute_1>, ResolveZodType<TParamsSchema_1>>, ResolveZodType<TQuerySchema_1>, MergeRouteTypes<RouteMeta<TBaseRoute_1>, TMeta_1> & SharedMeta>> | undefined;
    }) => Route<MergeRouteTypes<RouteParams<TBaseRoute_1>, ResolveZodType<TParamsSchema_1>>, ResolveZodType<TQuerySchema_1>, TEvent_1, MergeRouteTypes<RouteMeta<TBaseRoute_1>, TMeta_1> & SharedMeta>;
};

// Warning: (ae-forgotten-export) The symbol "MarkOptionalLikePropertiesOptional" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "RootOptions" needs to be exported by the entry point index.d.ts
//
// @public
export function buildRootComponent<TMachine extends AnyXstateTreeMachine>(options: {
    machine: TMachine;
} & MarkOptionalLikePropertiesOptional<RootOptions<InputFrom<TMachine>>>): {
    ({ children, }: {
        children?: React_2.ReactNode;
    }): JSX.Element;
    rootMachine: TMachine;
};

// @public
export function buildRoutingMachine<TRoutes extends AnyRoute[]>(_routes: TRoutes, mappings: Record<TRoutes[number]["event"], AnyXstateTreeMachine>): AnyXstateTreeMachine;

// Warning: (ae-internal-missing-underscore) The name "CanHandleEvent" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type CanHandleEvent<TMachine extends AnyStateMachine> = (e: EventFrom<TMachine>) => boolean;

// @public
export function createXStateTreeMachine<TMachine extends AnyStateMachine, TSelectorsOutput = ContextFrom<TMachine>, TActionsOutput = Record<never, string>, TSlots extends readonly Slot[] = []>(machine: TMachine, options: V2BuilderMeta<TMachine, TSelectorsOutput, TActionsOutput, TSlots>): XstateTreeMachine<TMachine, TSelectorsOutput, TActionsOutput, TSlots>;

// @public
export const genericSlotsTestingDummy: any;

// @public (undocumented)
export type GetSlotNames<TSlots extends readonly Slot[]> = TSlots[number]["name"];

// @public
export type GlobalEvents = {
    [I in keyof XstateTreeEvents]: XstateTreeEvents[I] extends string ? {
        type: I;
    } : XstateTreeEvents[I] & {
        type: I;
    };
}[keyof XstateTreeEvents];

// Warning: (ae-forgotten-export) The symbol "Options" needs to be exported by the entry point index.d.ts
//
// @public
export function lazy<TMachine extends AnyXstateTreeMachine>(factory: () => Promise<TMachine>, { Loader, input }?: Options<TMachine>): AnyXstateTreeMachine;

// Warning: (ae-forgotten-export) The symbol "LinkInner" needs to be exported by the entry point index.d.ts
//
// @public
export const Link: <TRoute extends AnyRoute>(props: {
    to: TRoute;
    children: React_2.ReactNode;
    testId?: string | undefined;
    onClick?: ((e: React_2.MouseEvent<HTMLAnchorElement>) => boolean | void) | undefined;
    preloadOnInteraction?: boolean | undefined;
    preloadOnHoverMs?: number | undefined;
} & RouteArguments<TRoute extends Route<infer TParams, any, any, any> ? TParams : undefined, TRoute extends Route<any, infer TQuery, any, any> ? TQuery : undefined, TRoute extends Route<any, any, any, infer TMeta> ? TMeta : undefined> & Omit<React_2.AnchorHTMLAttributes<HTMLAnchorElement>, "href" | "onClick"> & {
    ref?: React_2.ForwardedRef<HTMLAnchorElement> | undefined;
}) => ReturnType<typeof LinkInner>;

// @public (undocumented)
export type LinkProps<TRoute extends AnyRoute, TRouteParams = TRoute extends Route<infer TParams, any, any, any> ? TParams : undefined, TRouteQuery = TRoute extends Route<any, infer TQuery, any, any> ? TQuery : undefined, TRouteMeta = TRoute extends Route<any, any, any, infer TMeta> ? TMeta : undefined> = {
    to: TRoute;
    children: React_2.ReactNode;
    testId?: string;
    onClick?: (e: React_2.MouseEvent<HTMLAnchorElement>) => boolean | void;
    preloadOnInteraction?: boolean;
    preloadOnHoverMs?: number;
} & RouteArguments<TRouteParams, TRouteQuery, TRouteMeta> & Omit<React_2.AnchorHTMLAttributes<HTMLAnchorElement>, "href" | "onClick">;

// @public (undocumented)
export function loggingMetaOptions<TEvents extends EventObject, TContext>(ignoredEvents: TEvents["type"][], ignoreContext?: (keyof TContext)[] | undefined): {
    xstateTree: {
        ignoredEvents: Map<string, boolean>;
        ignoreContext: (keyof TContext)[] | undefined;
    };
};

// Warning: (ae-forgotten-export) The symbol "ToStatePaths" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "MatchesFrom" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type MatchesFrom<T extends AnyStateMachine> = (value: ToStatePaths<SnapshotFrom<T>["value"]>) => boolean;

// Warning: (ae-forgotten-export) The symbol "Return" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function matchRoute<TRoutes extends Route<any, any, any, any>[]>(routes: TRoutes, basePath: string, path: string, search: string): Return<TRoutes>;

// @public
export type Meta<T> = T extends {
    meta: infer TMeta;
} ? TMeta : undefined;

// @public (undocumented)
export type MultiSlot<T extends string> = {
    type: SlotType.MultiSlot;
    name: `${T}Multi`;
    getId(id: string): string;
};

// @public (undocumented)
export function multiSlot<T extends string>(name: T): MultiSlot<T>;

// @public
export function onBroadcast(handler: (event: GlobalEvents) => void): () => void;

// @public
export type Params<T> = T extends {
    params: infer TParams;
} ? TParams : undefined;

// @public
export type PickEvent<T extends Extract<GlobalEvents, {
    type: string;
}>["type"]> = Extract<GlobalEvents, {
    type: T;
}>;

// @public
export type Query<T> = T extends {
    query: infer TQuery;
} ? TQuery : undefined;

// @public
export type Route<TParams, TQuery, TEvent, TMeta> = {
    matches: (url: string, search: string) => ({
        type: TEvent;
        originalUrl: string;
    } & RouteArguments<TParams, TQuery, TMeta>) | false;
    reverse: RouteArgumentFunctions<string, TParams, TQuery, undefined>;
    navigate: RouteArgumentFunctions<void, TParams, TQuery, TMeta>;
    preload: RouteArgumentFunctions<void, TParams, TQuery, TMeta>;
    getEvent: RouteArgumentFunctions<{
        type: TEvent;
    } & RouteArguments<TParams, TQuery, TMeta>, TParams, TQuery, TMeta>;
    matcher: (url: string, query: ParsedQuery<string> | undefined) => (RouteArguments<TParams, TQuery, TMeta> & {
        matchLength: number;
    }) | false;
    reverser: RouteArgumentFunctions<string, TParams, TQuery, TMeta>;
    event: TEvent;
    history: () => XstateTreeHistory;
    basePath: string;
    parent?: AnyRoute;
    paramsSchema?: Z.ZodObject<any>;
    querySchema?: Z.ZodObject<any>;
    redirect?: RouteRedirect<TParams, TQuery, TMeta>;
    canMatch?: RouteArgumentFunctions<boolean, TParams, TQuery, TMeta>;
};

// Warning: (ae-forgotten-export) The symbol "IsEmptyObject" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "EmptyRouteArguments" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type RouteArgumentFunctions<TReturn, TParams, TQuery, TMeta, TArgs = RouteArguments<TParams, TQuery, TMeta>> = IsEmptyObject<TArgs> extends true ? () => TReturn : keyof TArgs extends "meta" ? (args?: TArgs) => TReturn : EmptyRouteArguments<TParams, TQuery> extends true ? (args?: Partial<TArgs>) => TReturn : (args: MarkOptionalLikePropertiesOptional<TArgs>) => TReturn;

// @public (undocumented)
export type RouteArguments<TParams, TQuery, TMeta> = TParams extends undefined ? TQuery extends undefined ? TMeta extends undefined ? {} : {
    meta?: TMeta;
} : TMeta extends undefined ? {
    query: TQuery;
} : {
    query: TQuery;
    meta?: TMeta;
} : TQuery extends undefined ? TMeta extends undefined ? {
    params: TParams;
} : {
    params: TParams;
    meta?: TMeta;
} : TMeta extends undefined ? {
    params: TParams;
    query: TQuery;
} : {
    params: TParams;
    query: TQuery;
    meta?: TMeta;
};

// @public
export type RouteMeta<T> = T extends Route<any, any, any, infer TMeta> ? TMeta : undefined;

// @public
export type RouteParams<T> = T extends Route<infer TParams, any, any, any> ? TParams : undefined;

// @public
export type RouteQuery<T> = T extends Route<any, infer TQuery, any, any> ? TQuery : undefined;

// @public (undocumented)
export type Routing404Event = {
    type: "ROUTING_404";
    url: string;
};

// @public
export type RoutingEvent<T> = T extends Route<infer TParams, infer TQuery, infer TEvent, infer TMeta> ? {
    type: TEvent;
    originalUrl: string;
    params: TParams;
    query: TQuery;
    meta: TMeta;
} : never;

// @public (undocumented)
export type Selectors<TMachine extends AnyStateMachine, TOut> = (args: {
    ctx: ContextFrom<TMachine>;
    canHandleEvent: CanHandleEvent<TMachine>;
    inState: MatchesFrom<TMachine>;
    meta?: unknown;
}) => TOut;

// @public
export type SelectorsFrom<TMachine extends AnyXstateTreeMachine> = TMachine["_xstateTree"] extends XstateTreeMachineStateSchemaV2<any, infer TOut, any, any> ? TOut : never;

// @public (undocumented)
export type SharedMeta = {
    doNotNotifyReactRouter?: boolean;
    indexEvent?: boolean;
    replace?: boolean;
    onloadEvent?: boolean;
};

// @public (undocumented)
export type SingleSlot<T extends string> = {
    type: SlotType.SingleSlot;
    name: T;
    getId(): string;
};

// @public (undocumented)
export function singleSlot<T extends string>(name: T): SingleSlot<T>;

// @public (undocumented)
export type Slot = SingleSlot<any> | MultiSlot<any>;

// @public (undocumented)
export enum SlotType {
    // (undocumented)
    MultiSlot = 1,
    // (undocumented)
    SingleSlot = 0
}

// @public (undocumented)
export type StyledLink<TStyleProps = {}> = <TRoute extends AnyRoute>(props: LinkProps<TRoute> & TStyleProps) => JSX.Element;

// @public
export function TestRoutingContext({ activeRouteEvents, children, }: {
    activeRouteEvents: RoutingEvent<AnyRoute>[];
    children: React_2.ReactNode;
}): JSX.Element;

// @public
export function useActiveRouteEvents(): {
    type: string;
    originalUrl: string;
    params: unknown;
    query: unknown;
    meta: unknown;
}[] | undefined;

// @public
export function useIsRouteActive(...routes: AnyRoute[]): boolean;

// @public
export function useOnRoute(route: AnyRoute): boolean;

// @public
export function useRouteArgsIfActive<TRoute extends AnyRoute>(route: TRoute): ArgumentsForRoute<TRoute> | undefined;

// @public (undocumented)
export type V2BuilderMeta<TMachine extends AnyStateMachine, TSelectorsOutput = ContextFrom<TMachine>, TActionsOutput = Record<never, string>, TSlots extends readonly Slot[] = Slot[]> = {
    selectors?: Selectors<TMachine, TSelectorsOutput>;
    actions?: Actions<TMachine, TSelectorsOutput, TActionsOutput>;
    slots?: TSlots;
    View: View<TActionsOutput, TSelectorsOutput, TSlots>;
};

// @public (undocumented)
export type View<TActionsOutput, TSelectorsOutput, TSlots extends readonly Slot[]> = React_2.ComponentType<{
    slots: Record<GetSlotNames<TSlots>, React_2.ComponentType>;
    actions: TActionsOutput;
    selectors: TSelectorsOutput;
    children?: React_2.ReactNode;
}>;

// @public
export function viewToMachine(view: (args?: any) => JSX.Element | null): AnyXstateTreeMachine;

// @public (undocumented)
export type XstateTreeHistory<T = unknown> = History_2<{
    meta?: T;
    previousUrl?: string;
}>;

// Warning: (ae-forgotten-export) The symbol "RepairProvideReturnType" needs to be exported by the entry point index.d.ts
// Warning: (ae-incompatible-release-tags) The symbol "XstateTreeMachine" is marked as @public, but its signature references "XstateTreeMachineInjection" which is marked as @internal
//
// @public (undocumented)
export type XstateTreeMachine<TMachine extends AnyStateMachine, TSelectorsOutput = ContextFrom<TMachine>, TActionsOutput = Record<never, string>, TSlots extends readonly Slot[] = Slot[]> = RepairProvideReturnType<TMachine, TSelectorsOutput, TActionsOutput, TSlots> & XstateTreeMachineInjection<TMachine, TSelectorsOutput, TActionsOutput, TSlots>;

// Warning: (ae-internal-missing-underscore) The name "XstateTreeMachineInjection" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type XstateTreeMachineInjection<TMachine extends AnyStateMachine, TSelectorsOutput = ContextFrom<TMachine>, TActionsOutput = Record<never, string>, TSlots extends readonly Slot[] = Slot[]> = {
    _xstateTree: XstateTreeMachineStateSchemaV2<TMachine, TSelectorsOutput, TActionsOutput, TSlots>;
};

// @public (undocumented)
export type XstateTreeMachineStateSchemaV2<TMachine extends AnyStateMachine, TSelectorsOutput = ContextFrom<TMachine>, TActionsOutput = Record<never, string>, TSlots extends readonly Slot[] = Slot[]> = Required<V2BuilderMeta<TMachine, TSelectorsOutput, TActionsOutput, TSlots>>;

// Warnings were encountered during analysis:
//
// src/routing/createRoute/createRoute.ts:292:19 - (ae-forgotten-export) The symbol "MergeRouteTypes" needs to be exported by the entry point index.d.ts
// src/routing/createRoute/createRoute.ts:292:19 - (ae-forgotten-export) The symbol "ResolveZodType" needs to be exported by the entry point index.d.ts
// src/routing/createRoute/createRoute.ts:329:9 - (ae-forgotten-export) The symbol "RouteRedirect" needs to be exported by the entry point index.d.ts
// src/types.ts:164:3 - (ae-incompatible-release-tags) The symbol "canHandleEvent" is marked as @public, but its signature references "CanHandleEvent" which is marked as @internal
// src/types.ts:165:3 - (ae-incompatible-release-tags) The symbol "inState" is marked as @public, but its signature references "MatchesFrom" which is marked as @internal

// (No @packageDocumentation comment for this package)

```
